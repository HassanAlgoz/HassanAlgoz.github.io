[
  {
    "title": "علوم الحاسوب (مقدمة مختصرة)",
    "body": "<blockquote class=\"twitter-tweet\" data-lang=\"ar\" data-dnt=\"true\" data-theme=\"light\"><p lang=\"ar\" dir=\"rtl\">علوم الحاسوب (مقدمة مختصرة) 2020 <a href=\"https://t.co/GQ9hGx3YcI\">https://t.co/GQ9hGx3YcI</a> <br>هذا المقطع يعطيك تصوُّر عن علوم الحاسب بشكل مختصر في نصف ساعة.</p>&mdash; حسان القوز (@Hassan_Algoz) <a href=\"https://twitter.com/Hassan_Algoz/status/1304631399639642112?ref_src=twsrc%5Etfw\">١٢ سبتمبر ٢٠٢٠</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>اكتب ردًّا على التغيردة للتعليق على الموضوع، أو على مقطع اليوتيوب.</p>\n<h1 id=\"\">علوم الحاسوب</h1>\n<p>علوم الحاسوب تُعنى بإيجاد حلول كُلّيَّة خوارزمية للمسائل؛ فالحاسوب ما هو إلا أداة تنفيذ خوارزميات ، والخوارزميات ما هي إلا خطوات المعالجة المؤدية للحل. ونقصد بالحل الكلي: المُجرَّد عن أعيان المسألة. فيمكن أن نقول أن المبحث الأول في علوم الحاسوب هو الخوارزميات.</p>\n<p>وأي خوارزمية يستطيعها الحاسوب، فإنَّ أي حاسوبٍ بشري يستطيعها -إذا أطلقنا الوقت والجهد- بورقة وقلم، دون تفكير -لو اعتبرنا أنه لا يُخطئ في تتبع الخطوات-.</p>\n<p>أما مستوى إجمال الخُطوة وتفصيلُها فيرجع إلى لغة البرمجة، فكل خوارزمية عبارة عن خوارزمياتٍ جزئية، وهكذا يستمر التضمين حتى نصل إلى العمليات الأوَّلية المنطقية للمعالجة الرقمية، ولُغة البرمجة إذا عَلَت (تجرَّدَت عن التفاصيل)، صارت الخوارزميات أبسط، لكنها قد تسلِبُك الدِّقَّة عند بعض التفاصيل.</p>\n<p>وغالبًا ما تُفكك المسألة لتصبِحَ مسائل، لكلٍّ منها خوارزمية، ثم يركَّبُ الحلُّ فتتكون خوارزمية جامعة.</p>\n<p>ولغة البرمجة تتضمن مفرداتٍ للتحكم في سير تنفيذ الخطوات: كالعبارة الشرطية (لسلوك مسار بحسبِ الشرط)، وعبارة التكرار (للمعالجات المتكررة)، وهي في الأصل دون تحكُّم تسير في التنفيذ بالترتيب من الأعلى للأسفل.</p>\n<p>والمبحث المحوري الثاني: المعلومات، التي تتكون من بيانات؛ يُبحثُ تمثيلها والعمليات عليها، وهو مجالٌ واسعٌ؛ إذ لكلِّ نوعٍ من المعلومات خصائصه التي يُمكن بحثُها لتمثيلها في البيئة الرقمية.</p>\n<p>ففي تمثيل الملفات: الصُّوَر والمقاطع المرئية والمسموعة والكُتُب وغيرها، كلٌّ له عدة صيَغٍ في تمثيله رقميًّا، وهي تتفاوَت في الدقة (الجوْدة) والحجم، ومعايير أخرى= بحسب تمثيلها.</p>\n<h1 id=\"-1\">أنواع المسائل في علوم الحاسوب</h1>\n<h2 id=\"-2\">مسألة قرار</h2>\n<p>يكون الجواب فيها لكل مُدخَل بنعم أو لا؛ فمثلاً: هل العدد س أوَّلي، أو هل س أكبر من ص، أو هل النص صحيح نحويًّا، أو هل توجد سيارة في الصورة.</p>\n<h2 id=\"-3\">مسألة بحث</h2>\n<p>يبحث الحلَّ في فضاء الاحتمالات؛ وهو يتضمَّن القرار، فمثلاً: البحث عن طريق سالك من نقطة إلى أخرى، أو البحث عن الجذر التربيعي لعدد.</p>\n<h2 id=\"-4\">مسألة عد</h2>\n<p>وتتضمن عدة مسائل بحث؛ مثلاً: عدد الإعرابات الصحيحة للجُملة، أو عدد الطُّرُق السالكة من نقطة إلى أخرى.</p>\n<h2 id=\"-5\">مسألة تفضيل</h2>\n<p>وهي مسألة بحثٍ وقرار؛ فهي تقريرُ أفضل حلٍّ ضمن حلولٍ صحيحة؛\nمثال1: أفضل مسار رحلة</p>\n<ol>\n<li>بحث الطرق السالكة من نقطة إلى أخرى</li>\n<li>تقرير أفضل طريق من بينها\nمثال2: أفضل خُطَّة للفوز</li>\n<li>بحث الخُطط المُمكنة بعُمق 10 خطوات (في لعبة الشطرنج مثلاً)</li>\n<li>تقرير أفضل الخُطط من بينها\nمثال3: أفضل جدوَل</li>\n<li>بحث كل الجداول التي تحقق شروطًا مُحددة (مثل غير متعارضة، وتكون في الصباح)</li>\n<li>تقرير أفضل جدوَل من بينها</li>\n</ol>\n<h1 id=\"-6\">التعقيد الخوارزمي</h1>\n<p>جوانب تعقيد الخوارزمية في الغالب جانبان: عدد العمليات ومساحة التخزين؛ فبعض الخوارزميات أفضلُ من غيرها لأنها تصل للحل بعدد عمليات أقل ولو تطلبت مساحة أكبر، وبعضها أفضل من الجانبين، وهذا يُدرَسُ في مجال تحليل وتصميم الخوارزميات «Design and Analysis of Algorithms».</p>\n<h2 id=\"-7\">المسألة المستعصية</h2>\n<p>المسألة المستعصية  هي ما لا يوجد لها حلٌّ مُطابقٌ إلا ويتفاقَمُ تعقيداً مع حجم المسألة، ونقصد بالتعقيد عدد الخطوات أو مساحة التخزين المطلوبة،  فإذا كانت مسألة تفضيل مستعصية؛ فإن القرار فيها يستعصي وقد لا يستعصي البحث. انظر مسألة: مندوب المبيعات المُسافِر «The Travelling Salesperson Problem».\nوبعضُ المسائل المستعصية يُمكن فحصُ صِحَّة حلها وإن لم يُمكن حلُّها عمليًّا.\nانظر أيضاً: نظرية قابلية الحوْسَبة «Computability Theory».</p>\n<h2 id=\"-8\">الحل التقريبي</h2>\n<p>الوسيلة لحل بعض المسائل المستعصية هو الاقتراب من الحل؛ والمثال المشهور الذي يُعاني منه الجميع: مسألة جدوَلة الحصص (المدرسية)، فالجدوَل الذي يقرره الحاسوب هو حلٌّ تقريبي؛ وذلك لأنه لا يستطيع أن يعتبر كُل فضاء الحل ويُقرر.\nوفي الغالب فإنه كُلَّ ما كان تكوينُ الخُطَّة في كُلِّ خطوة مؤثِّراً (ولو احتمالاً) على عدد أكبَر من المتغيِّرات صار لازمًا اعتبارُها ومُعالجتها، فيعسُر بقدر ذلك إيجادُ حلٍّ في وقتٍ عمليّ؛ فيُلجأ لطُرُقٍ تقريبية.</p>\n<h1 id=\"-9\">بعض مجالاته</h1>\n<p>موضوع علم الحاسوب: الحوسَبة والمعلومات؛ فنجد نظرية الحوسَبة تبحث ما يُمكن حِسابُه وما لا يُمكن حسابه، ومجال تحليل وتصميم الخوارزميات يبحث ما به يُفاضَلُ بينها بحسْبِ الاعتبار، والمعلوماتُ مبحثٌ أساسيٌّ: تمثيلُها وانتقالُها وحِفظُها والبحث عنها وفيها واختصارُها واسترجاعُها، وذلك مُتعلّقٌ بمجال هيكَلة البيانات وقواعد البيانات وأمن المعلومات والتشفير وغيره من علوم الحاسوب.\nواستخدم أقوامٌ الحاسوب أداةً لعلومهم؛ فظهر علم الفيزياء الحسابي، وعلم الكيمياء الحسابي، ومثله في الأحياء واللُّغات وغير ذلك كثير؛ إذْ تُحاكى الأنظِمَة في هذه العلوم بتمثيل المعلومات في الحاسوب وتعريف علاقاتِ المُتغيّرات، فينشأ نِظامٌ اصطناعيٌّ نموذجي يُمَكِّنُ الباحثين من تعديل مُتغيِّراتٍ ورؤيةِ أثر ذلك؛ وذلك يُوفِّر تكاليف التجاربِ الحيَّة حين يكون ذلك مُمكِنًا والنموذَجُ ضِمْنَ الدقة المطلوبة.</p>\n<p>وعلى أبوابِ المُستقبل علمُ الحوْسَبة الكميَّة الذي هو نقلة نوعيَّةٌ في علوم الحاسوب لكن قالوا لن يكون أثره في مجال تقنية المعلوماتِ أوَّلاً وقد لا يكونُ آخرًا، بل مجالاتُه الأولى ستكون في الكيمياء والأمور الدقيقة.</p>\n<p>وتطوَّرت أجهزة الحاسوب فتضاعفت قُدرة المُعالَجة أضعافًا مع تضاعُفِ التخزين إلى جانِب نمُوِّ عدد البيانات التي تُجمَعُ وتتداول على الشبكة= فأصبح مُمكِنًا تطبيق نظريات الذكاء الاصطناعي والتي من أهمِّها نظرية العصبونات الاصطناعية، فصار التعرُّف على الأنماطِ المُعقَّدة مُمكنًا؛ فتعرَّف على الوجوه والأصوات والكلام، وصار ينطقُ ما يُكتبُ له، ويجِدُ جوابًا لما يُسألُ عنه؛ ولا يزال البحث والتطوير في الذكاء الاصطناعي مُستمرًّا.</p>\n<p>ومهندسو الحاسوب يبحثون في تصميمها وتوصيلِها وتفاصيل ذلك، وهُم يتعاملون مع الجُزءِ الماديّ له وكذلك البرمجيّ.</p>\n<p>أما هندسة البرمجيات فمجالٌ يُعامِل البرامِج المُركَّبة كمشاريعَ كبيرة -وهي كذلك-، ومجالُهم التطبيقات والمواقِعُ والخوادِمُ وما إلى ذلك. وقيل: هندسة البرمجيات هي حاصل إضافة عامِلَ الوقت إلى البرمجة.</p>\n<p>وهُناك علومٌ وأمورٌ متعلقة وتطبيقاتٌ لم أتطرق إليها وهي كثيرة، لكن لعل في ما ذُكر كفاية في تصوُّرِ علوم الحاسوب ومجالاتها العامَّة وموضوعِها الأساسي وثمرات ذلك.</p>",
    "link": "/posts/cs-intro.html",
    "date": "2020-09-00",
    "category": "posts",
    "desc": "محاولة تصوير علوم الحاسوب للقارئ ليتعرف عليه",
    "lang": "ar",
    "dir": "rtl"
  },
  {
    "title": "معالجة الخطأ المُبرمَج وإصلاح الغلط الإنشائي",
    "body": "<p>بسم الله الرحمن الرحيم.</p>\n<h1 id=\"\">مقدمة</h1>\n<p>يعمل البرنامج بسلام، ثم بعد فترة ومن غير أي تعديل في النص البرمجي، تظهر مشاكل جديدة غير متوقَّعة! نضطر لإيقاف البرنامج وإصلاحه، ثم نطلقه ثانيةً فيلبث فترة من الزمان، ثم تأتي الشكاوي من المستخدمين!</p>\n<p>ولمثل هذا السبب شرعت في البحث في مسألة الأخطاء البرمجية، وإليك خلاصة هذا البحث تحت هذه الخطوط العريضة:</p>\n<ul>\n<li>معيار صحَّة البرنامج</li>\n<li>الفرق بين الخطأ المُبرمَج والغلط الإنشائي<ul>\n<li>سبب الخلط بين الخطأ المُبرمَج والغلط الإنشائي</li></ul></li>\n<li>معالجة الخطأ المُبرمَج<ul>\n<li>الرقم في مقابل الشذوذ</li>\n<li>استرجاع حال ما قبل الإجراء</li>\n<li>تسلسل الأخطاء</li>\n<li>إيصال رسالة الخطأ</li>\n<li>إهمال الخطأ المُبرمَج</li></ul></li>\n<li>إصلاح الغلط الإنشائي<ul>\n<li>المرحلة الأولى: العلم بوجود الغلط</li>\n<li>المرحلة الثانية: تتبع أصل الغلط</li>\n<li>المرحلة الثالثة: إصلاح الغلط</li></ul></li>\n</ul>\n<h1 id=\"-1\">معيار صحَّة البرنامج</h1>\n<p>البرنامج إجراءات تعمل على بيانات؛ وصحة الإجراء أن تُصِّدق تفاصيلُه وصفَه.</p>\n<p>والإجراء له وصفان: وصفٌ بلغة البرمجة، ووصفٌ بلغة الخطاب. فالأوَّل تفهمه الأدوات البرمجية فتساعدك في الكتابة والتعديل والقراءة، وهو الذي يتحوَّل إلى أوامِر تنفيذية، والثاني يفهمه المستخدم (المبرمج) ويُسمَّى التوثيق (documentation).</p>\n<p>وبالتوثيق يُعرف مدى تأثر وتأثير الإجراء؛ فقد يتأثر بغير مُدخلاته، أو يؤثِّرُ هو بمدخلاته، أو يؤثّر في غير محلّ مخرجاته، ومثل ذلك يصعُب ضبطه فاجتنابه أسلم وأقرب للصحة.</p>\n<p>والوصف بلغة البرمجة يحوي مُعرِّف الإجراء، وقيوداً أخرى.</p>\n<p>فمُعرِّف الإجراء (function signature): هو ما يُميَّز به بين إجراءٍ وآخر، فمن ذلك: اسم الإجراء ومدخلاته ونوعها ومخرجاته ونوعها. فإذا اتفق اسمان، عرف البرنامج أي الإجرائين يُجري باختلاف الحدود الأخرى للمعرِّف. وهذا يُعرف باسم (function overloading). وقد تقيِّد اللغة المدخلات والمخرجات بما يزيد عن تحديد نوعها، وهو ما يُعرفُ بالتوكيد (assertion).</p>\n<p>فإذا قرأ المستخدم الوصفين عرف ما يأخذ الإجراء وما يُخرج، فلا يعطيه ما لا يقبل ولا يتوقَّع منه ما لا يضمن.</p>\n<h1 id=\"-2\">الفرق بين الخطأ المُبرمَج والغلط الإنشائي</h1>\n<p>ومن مُخرجات الإجراء: الخطأ (المُبرمَج). سواء خرج بالرجوع (return) أو بالرمي (throw).</p>\n<p><strong>فالخطأ المُبرمَج</strong>: يحدث حين تُفحص البيانات فيقرر أنها في حالة غير صالحة للمعالجة. مثلاً:  انقطاع الشبكة، أو فقدان ملفّ توقَّع في مكانٍ ما، أو إدخال عددٍ مكان حرفٍ، أو إدخال قيمة أكبر من الحد الأعلى، ..إلخ.</p>\n<p>أما <strong>الغلط في الإنشاء</strong>: فإنَّه خروج البرنامج عما بُرمِجَ له. وهو غلط من أنشأ شيئًا من البرنامج، ولذلك فإنه حين يقع لا حوْل للبرنامج في معالجته إلا بالتوقُّف والإبلاغ عنه.</p>\n<h2 id=\"-3\">سبب الخلط بين الخطأ المُبرمَج والغلط الإنشائي</h2>\n<p>وسبب الخلط بينهما لغاتٌ جعلت آلية معالجة الخطأ المُبرمَج تُمسك الغلط الإنشائي، مع أن البرنامج لا يستطيع معالجته إلا أن يستُرَ عليه ليُفسِد ويتفاقم، ومن هذه الأغلاط:</p>\n<ol>\n<li>طلب معدومٍ (Null Dereference)</li>\n<li>تحويل نوع خاطئ (Incorrect Casting)</li>\n<li>أخذ بيانات خارِجَ نطاق حاويها منه (Out-of-bounds Access Violation)</li>\n<li>تنفيذ قسمة عدد على صِفر (Divide by Zero)</li>\n<li>الدخول في تكرار لا نهائي (Infinite Loop)</li>\n<li>تجاوُز حسابي علوي أو سفلي (Arithmetic Overflow or Underflow)</li>\n<li>تكديس متجاوِز (Stack Overflow)</li>\n<li>تمرير بيانات من نوع خاطئ (Invalid Argument)</li>\n<li>عدم تعيين جميع المدخلات (Missing Argument)</li>\n</ol>\n<p>فترى Java و Python وغيرها، تستعمل try-catch throw لهذه الأغلاط والأخطاء المُبرمَجة، وهذا غلطٌ إنشائي أصليّ في هذه اللغات، ولذلك فإن لغاتٍ حديثة أتت وتداركت هذا الغلط، مثل: Rust, Go على سبيل المثال لا الحصر.</p>\n<h1 id=\"-4\">معالجة الخطأ المُبرمَج</h1>\n<p>فالإجراء له طريقان مع حدوث الخطأ فيه:</p>\n<p>الأول: أن يُخرج الخطأ لمن يستدعيه، فيكون بذلك أسند معالجته إليه.</p>\n<p>الثاني: أن يُعالِجه هو، ويخفي على المستدعي أنه حدث أصلاً.</p>\n<p>وبحسب الخطأ نعالجه:</p>\n<ul>\n<li>نُعلم المستخدم بوجود الخطأ</li>\n<li>نعاود العملية مرة أخرى بعد فترة زمنية معيَّنة (وقد تكون باستخدام بيانات مختلفة)</li>\n<li>نستخدم بديلاً</li>\n<li>نستشير المستخدم</li>\n<li>نوقف البرنامج</li>\n</ul>\n<h2 id=\"-5\">فروقات لغوية: الرقم في مقابل الشذوذ</h2>\n<p>وشقَّت اللغات طريقين:</p>\n<ol>\n<li>الشذوذ (Exception)</li>\n<li>ترقيم الأخطاء (Error Codes)</li>\n</ol>\n<p>مثال الشذوذ بالخطأ: الإجراء في لغة Java و Python يشذُّ بالخطأ المُبرمَج عند (throw)، فإن كان داخل (try) أُكمِل التنفيذ في منطقة (catch) بحسب نوعه، ولكلِّ نوعٍ (catch)، ثُمَّ أخيراً ينفذ ما في منطقة (finally).</p>\n<p>مثال الرجوع بالخطأ: وهي طريقة C  و  Go وغيرها مع اختلافات بينها، فالخطأ يرجع كأي قيمة ترجعها الدالة، وعُرفيًّا في لغة Go يكون الخطأ آخر مُخرج، فيُطابق رقم الخطأ لمعرفة نوعه، ويتعامل معه الإجراء بحسبه. وتكون الأرقام ثوابِتَ مُعرَّفةً بأسماء، مثل: 12=ENOENT=2, ENOMEM (في C) ولكلٍّ منها دلالته.</p>\n<p>والفرق أيضًا في تفاصيل كلتا الطريقتين، لكن نكتفي بهذا القدر.</p>\n<h2 id=\"-6\">استرجاع حال ما قبل الإجراء</h2>\n<p>فإن كان الإجراء أتمَّ خُطُواتٍ أثَّرَت خارجه، فإن تأتَّى استرجاع الحال الأولى كان حسَناً وإلا فبرسالة خطأ تُنبئ عن ذلك، وإن كان الخروج بالخطأ لا يُفيد فعليك بإيقاف البرنامَج.</p>\n<p>وتجد لذلك (finally) وهي ما يُنفَّذ في نهاية الأمر ولو أخطأ الإجراء إن كان دخل في (try)،  أو (defer) وتنفّذ ما أُعطيَت حين الخروج بترتيبٍ عكسي.</p>\n<h2 id=\"-7\">تسلسل الأخطاء</h2>\n<p>فالأخطاء تكون متسلسلة، فمثلاً: \"تعذر رفع الملف: تعذر الوصول للخادم: تعذر الاتصال بالشبكة\"، هذا الخطأ سلسلة من ثلاثة أخطاء أصلُها \"تعذر الاتصال بالشبكة\"، فقد يعالج إجراءٌ هذا الخطأ بأن يُعاوِد رفع الملف بعد حين.</p>\n<ul>\n<li>سَلسَلة الأخطاء في نود: <a href=\"https://github.com/joyent/node-verror\">node-verror</a></li>\n<li>سَلسَلة الأخطاء في جو: <a href=\"https://blog.golang.org/go1.13-errors\">go1.13-errors</a></li>\n</ul>\n<h2 id=\"-8\">إيصال رسالة الخطأ</h2>\n<p>وأبسط صور ذلك أن يكتب رسالة الخطأ كما هي للمستخدم ليراها وحسب.</p>\n<p>وقد يُخيِّر البرنامج المستخدم؛ فيختار فيمشي البرنامج بناءً على اختياره.</p>\n<p>لكن الخطأ قد لا يعني المستخدم، وإنما يعني المطوّر أو مدير النظام الذي يشتغل عليه البرنامج، فحينها يُكتب الخطأ بصيغة معيَّنة ويُحفظ في سجلّ (log)، وقد يستأذن البرنامجُ المستخدم في إرسال رسالة الخطأ للمعني به. ولا بد في هذه الرسالة أن تكون دالَّة قدر الإمكان على سبب الخطأ ومكانه وحال البرنامج حينه، لأن ذلك يُسهِّلُ معالجته.</p>\n<h2 id=\"-9\">إهمال الخطأ المُبرمَج</h2>\n<p>الخطأ معلومة أقلُّ ما تفيده عدم تمام الإجراء المطلوب، وبالتالي فإن إهمال هذه المعلومة غلطٌ في إنشاء البرنامج، حيثُ لم يُستكمل منطقه، ثم تتفاجؤ بعد عمل البرنامج لفترة بوجود أخطاء غريبة وبتوقف البرنامج، وأشياء لم تتوقعها.</p>\n<p>وإن كان لك الخيار، فلا تختر لغةً الأصل فيها الإهمال مثل: JavaScript, PHP, Python, وغيرها، بل اختر لغة تعينك لا لغة تغشُّك.</p>\n<h1 id=\"-10\">إصلاح الغلط الإنشائي</h1>\n<p>وإني أحرِّص عليك أن لا تسوِّف معالجة ما تراه من علامات على وجود الأغلاط الإنشائية، لأنَّ ذلك يُنسى مع طول زمن المشروع، كما أنه بتراكمه يصعب معالجته لا كما لو أُصلح في حينه، وإن تُرك فإنه يكون سبباً لأغلاط أخرى، وهي مثله.</p>\n<p>وإن كنت لا بُدَّ مؤجِّلاً؛ فسجّل الغلط وتاريخه وحال المشروع حينه حتى لا تنساه وحتى لا يخفى على من يأتي بعدك ممن لم يشهده معك.</p>\n<h2 id=\"-11\">المرحلة الأولى: العلم بوجود الغلط</h2>\n<p>وعدوُّ ذلك أن يُمسكه فيكتمه ويُكمل، لأنه بذلك يُكنُّ فساداً يستشري إلى بقية أجزائه وقد يخرج إلى الأنظمة الأخرى المتصلة به، ثم قد لا يظهر إلا بعد إحداث أغلاطٍ إنشائية وأخطاءٍ مُبرمَجة أخرى، فيصعب حينئذٍ تتبع أصل الغلط لإصلاحه.</p>\n<p>وهذا يعود بالدرجة الأولى للغة البرمجة (مفرداتها وأدواتها التي تحلل تركيباتها)، فمن الأغلاط الإنشائية ما يُمكن ضبطه بالتحليل الآلي للبرنامج المكتوب، ومنها ما يستحيل ضبطه لأنه صحيح التركيب لكن على وجهٍ لا يحقق المراد.</p>\n<h2 id=\"-12\">المرحلة الثانية: تتبع أصل الغلط</h2>\n<p>تفرز اللغة رسالة آليَّة تحتوي سلسلة الاستدعاءات التي كانت حين حدوث الغلط، واسم الملف ورقم السطر الذي حصل فيه.</p>\n<p>ويُمكن استعمال المدقق (debugger) الذي يوقف البرنامج عند نقاط توقُّف محدده، ويُطْلعه على حال البرنامج عند تلك النقطة، كما يُمكّنه من التحكم في التنفيذ بالخطوِ خطوة واحدة أو الإكمال العادي حتى نقطة توقُّف قادمة.</p>\n<p>أما استعمال الكتابة على السجلات الظاهرة باستعمال (console.log) أو (printf) ومثيلاتها بغرض التدقيق، فإن ذلك غالبًا ما يكون أفضل منه استعمال المدقق، ولذلك يَحسُن بالمبرمج تعلم استخدام مدقق لغته.</p>\n<h2 id=\"-13\">المرحلة الثالثة: إصلاح الغلط</h2>\n<p>ولا نبدأ بالإصلاح إلا بعد تعيين أصل الغلط، ثم يكون موضِعُ الإصلاح ذلك الموضع لا غيره،  وقد يكون بإزالة أو إضافة أو تعديل أو تغيير ترتيب، ونحرص فيه أن نُصلِحَ ما يترتب على هذا الإصلاح من الأغلاط في مواضع أخرى.</p>\n<p>وليس من الأمانة ترقيع الأغلاط، ولا إسكات الأخطاء، أو تعمُّد مخالفة وصف الإجراء لتفاصيله، أو افتعال الأغلاط أو تعمُّد الإنشاء الهشّ، فإنَّ فعل ذلك في البرمجيات مثل فعله في الإنشاءات (المباني).</p>\n<h1 id=\"-14\">مصادر</h1>\n<ul>\n<li>تفصيل دقيق ونقل تجربة فريدة: <a href=\"http://joeduffyblog.com/2016/02/07/the-error-model/\">نموذج الخطأ - مدوَّنة جو دفّي</a></li>\n<li>نصائح عملية مفصَّلة: <a href=\"https://www.joyent.com/node-js/production/design/errors\">معالجة الخطأ في نود - جوي نِت</a></li>\n<li><a href=\"https://blog.golang.org/error-handling-and-go\">معالجة الخطأ وجو</a></li>\n<li><a href=\"https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html\">دليل لغة سويفت</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Exception_safety\">ضمانات الشذوذ - ويكيبيديا</a></li>\n</ul>",
    "link": "/posts/handle-errors-fix-bugs.html",
    "date": "2020-12-01",
    "category": "posts",
    "lang": "ar",
    "dir": "rtl"
  },
  {
    "title": "Comparing Server-side Languages",
    "body": "<p>Comparing Go, PHP, Java, Python, and Node.js.</p>\n<h1 id=\"contentomitintoc\">Content <!-- omit in toc --></h1>\n<ul>\n<li><a href=\"#introduction\">Introduction</a></li>\n<li><a href=\"#where-php-stands\">Where PHP Stands</a></li>\n<li><a href=\"#php-at-facebook\">PHP at Facebook</a><ul>\n<li><a href=\"#hack-and-hhvm\">Hack and HHVM</a></li>\n<li><a href=\"#why-hasnt-facebook-migrated-away-from-php\">Why Hasn't Facebook Migrated Away From PHP?</a></li></ul></li>\n<li><a href=\"#php-developers-salary\">PHP Developers’ Salary</a></li>\n<li><a href=\"#php-a-fractal-of-bad-design\">PHP: A Fractal of Bad Design</a></li>\n<li><a href=\"#web-framework-benchmarks--techempower\">Web Framework Benchmarks – TechEmpower</a></li>\n<li><a href=\"#benchmarksgame\">BenchmarksGame</a></li>\n<li><a href=\"#where-nodejs-stands\">Where Node.js Stands</a></li>\n<li><a href=\"#go-at-google\">Go at Google</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ul>\n<h1 id=\"introduction\">Introduction</h1>\n<p>When choosing a tech stack or a programming language, we often factor in two things:</p>\n<ol>\n<li>Estimated cost</li>\n<li>Estimated time</li>\n</ol>\n<p>Most often, performance is neglected. Leading to long-term costs. Sure you \"get things done\" faster and cheaper, but you'll pay for it later, hiring more to fix bugful code and handle bottle necks, just to hit the limits of the framework/language. Hopefully, you find out.</p>\n<p>There are many aspects of programming that must be considered when deciding the best programming language for the job. Some metrics can be measured with numbers, while others are too complex to summarize with few numbers, hence, human intuition and experience are paramount.</p>\n<p>We will look at the following <strong>numbers</strong>:</p>\n<ul>\n<li><a href=\"https://insights.stackoverflow.com/survey/2019\">Overflow 2019 Developers’ Survey</a></li>\n<li>Framework Benchmarks <a href=\"https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext\">Round 17 of 2018-10-30</a> – TechEmpower</li>\n<li><a href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/\">BenchmarksGame's benchmarks</a> on PHP, Python, Java, Node.js and Go</li>\n</ul>\n<p>As well as the following <strong>cases</strong>:</p>\n<ul>\n<li>We will see what Facebook’s engineer Yishan Sparklepants Wong has to say about PHP at Facebook</li>\n<li>What the creator of Node.js has to say about Node.js vs. Go</li>\n<li>What is the stance of the creator of Express.js on Node.js and Go</li>\n<li>Google engineers such as Robert Love, Matt Welsh, and Rob Pike, on replacing C++, and Java with Go</li>\n</ul>\n<p>I would really appreciate your feedback. Please feel free to poke holes in my argument; in a constructive manner.</p>\n<h1 id=\"wherephpstands\">Where PHP Stands</h1>\n<p>Over 100,000 developers took the <a href=\"https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted\">Stack Overflow 2019 survey</a> from which the following table is extracted. Most Loved, Dreaded, and Wanted Languages:</p>\n<p><img src=\"/assets/img/go-report/loved,dreaded,wanted.PNG\" alt=\"Most Loved, Dreaded, and Wanted Languages (StackOverflow 2019 Survey)\" /></p>\n<ul>\n<li><strong>Most Loved</strong>: % of developers who are developing with the language or technology and have expressed interest in continuing to develop with it.</li>\n<li><strong>Most Dreaded</strong>: % of developers who are developing with the language or technology but have not expressed interest in continuing to do so.</li>\n<li><strong>Most Wanted</strong>: % of developers who are not developing with the language or technology but have expressed interest in developing with it.</li>\n</ul>\n<p>PHP lost its popularity to more modern languages like JavaScript (Node.js), Go, and Python’s versatile functionality that allows programing in many fields, including web development, which attracted lots of web developers.</p>\n<h2 id=\"phpatfacebook\">PHP at Facebook</h2>\n<p>“But Facebook is using PHP, aren’t they?” Well, when Facebook started in 2004, PHP was the best choice for web development, among few choices. However, nowadays, we have alternatives such as Python’s frameworks, Node.js, and Go. Keep in mind that <a href=\"https://www.zdnet.com/article/facebook-may-release-its-core-c-library-this-year/\">Facebook uses C++ heavily on its back-end systems for performance reasons</a>, and it’s not all just PHP.</p>\n<h3 id=\"hackandhhvm\">Hack and HHVM</h3>\n<p>Facebook engineers developed their own VM to run PHP code, as well as to run a different programming language they called <a href=\"https://hacklang.org/\">Hack</a>.  They have been moving away from PHP towards Hack. <a href=\"https://hhvm.com/\">HVVM</a>, Facebooks’ open source VM for executing Hack and PHP code, <a href=\"https://hhvm.com/blog/2018/09/12/end-of-php-support-future-of-hack.html\">is ending support for PHP</a>.</p>\n<h3 id=\"whyhasntfacebookmigratedawayfromphp\">Why Hasn't Facebook Migrated Away From PHP?</h3>\n<p><a href=\"https://www.zdnet.com/article/why-facebook-hasnt-ditched-php/\">Yishan Sparklepants Wong</a>, an engineer who worked at Facebook from December 2005 to March 2010. Replying to the question posted on Quora: “Why hasn't Facebook migrated away from PHP”, he says:</p>\n<ul>\n<li>Inertia is what keeps them from changing (the amount of code already written)</li>\n<li>To get by, they enforce very strict code conventions and reviews to avoid the flaws of the language</li>\n<li>Re-writing an entire codebase in another language is usually one of the worst things you can do, so at all levels there is a reluctance to do that</li>\n<li>The preferred strategy is to write new components in a de-coupled manner using a better language of choice (C++, Python, Erlang, Java, etc.);</li>\n</ul>\n<h2 id=\"phpdeveloperssalary\">PHP Developers’ Salary</h2>\n<p>You can find PHP at the bottom-left ..\n<img src=\"/assets/img/go-report/Salary-and-experience-by-language.png\" alt=\"Salary and Experience By Language (StackOverflow 2019 Survey)\" /></p>\n<h2 id=\"phpafractalofbaddesign\">PHP: A Fractal of Bad Design</h2>\n<blockquote>\n  <p>“Do not tell me that Facebook and Wikipedia are built in PHP. I’m aware! They could also be written in Brainfuck, but as long as there are smart enough people wrangling the things, they can overcome problems with the platform. For all we know, development time could be halved or doubled if these products were written in some other language; this data point alone means nothing.” – <a href=\"https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/\">eev.ee</a></p>\n</blockquote>\n<p>Read more:</p>\n<ul>\n<li><a href=\"https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/\">PHP: A Fractal of Bad Design</a></li>\n<li><a href=\"http://phpsadness.com/\">PHP sadness</a> by Eric Wastl</li>\n<li><a href=\"https://www.quaxio.com/wtf/php.html\">PHP turtles</a> by a previous co-author of Hack (Alok Menghrajani)</li>\n</ul>\n<p>Still not sure? then, let's look at <strong>benchmarks</strong>. Again, please read with an open mind.</p>\n<h1 id=\"webframeworkbenchmarkstechempower\">Web Framework Benchmarks – TechEmpower</h1>\n<p>This is a performance comparison of many web application frameworks executing fundamental tasks such as JSON serialization, database access, and server-side template composition. Each framework is operating in a realistic production configuration. Results are captured on cloud instances and on physical hardware. The test implementations are largely community-contributed, and all source is available at the GitHub repository.</p>\n<p>The following table is constructed from <a href=\"https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext\">Round 17 of 2018-10-30</a>. The first column shows the 6 different test types, and under each column corresponding to a programming language, is the score of the best framework in this test.</p>\n<p><strong>Note</strong>: I tried comparing the most popular frameworks in each language to reflect the experience of most developers and most code bases.</p>\n<p><img src=\"/assets/img/go-report/TechEmpower-Round17of2018-10-30.PNG\" alt=\"Round 17 of 2018-10-30 techempower benchmark\" /></p>\n<p>Below are the same results scale colored for better comparison:\n<img src=\"/assets/img/go-report/TechEmpower-Round17of2018-10-30-colored-scaled.PNG\" alt=\"Round 17 of 2018-10-30 techempower benchmark\" /></p>\n<p><strong>Interpretation</strong>: Go is the best in web dev., followed by Java, then Node.js. PHP comes last and doesn’t even compare to Python. <em>PHP (Laravel, Symfony) is a sure way to burn money</em>.</p>\n<h1 id=\"benchmarksgame\">BenchmarksGame</h1>\n<p>The following benchmarks show measurements of C, Java, Go, PHP, Node.js, and Python. The tables below are sorted by time, ascendingly. Our baseline, rank 0, is C. Benchmark <a href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/\">source link here</a>.</p>\n<p><img src=\"/assets/img/go-report/BenchmarksGame.PNG\" alt=\"Benchmarks Game: k-nucleotide, Mandelbrot, spectral-norm, fasta\" /></p>\n<p><strong>Interpretation</strong>: Go is the most performant, in both CPU time and memory usage. Python is always the slowest[1]. Statically typed languages (C, Java, and Go) outperformed dynamically typed languages (Node.js, Python, PHP).</p>\n<blockquote>\n  <p>[1] You might wonder how Python, with this performance, is used in Machine Learning and Artificial Intelligence. It is because the libraries used such as Numpy and others are written in C/C++ and are wrapped in Python, so you are actually calling C/C++ code from your Python code.</p>\n</blockquote>\n<h1 id=\"wherenodejsstands\">Where Node.js Stands</h1>\n<p>The very creator of Node.js, <a href=\"https://belitsoft.com/nodejs-development-services/go-vs-nodejs\">here</a> in 2017 says:</p>\n<blockquote>\n  <p>“I think Node is not the best system to build a massive server web. I would use Go for that. And honestly, that’s the reason why I left Node. It was the realization that: oh, actually, this is not the best server-side system ever” – <strong>Ryan Dahl</strong>.</p>\n</blockquote>\n<p>He also says:</p>\n<blockquote>\n  <p>“Yeah, I think it’s… for a particular class of application, which is like, if you’re building a server, I can’t imagine using anything other than Go”.</p>\n  <p>“So, that plus the fact that Go came out, and I didn’t see Node as being the ultimate solution to servers”.</p>\n</blockquote>\n<p>You may also want to watch <a href=\"https://www.youtube.com/watch?v=M3BM9TB-8yA\">Things I Regret About Node.js – Ryan Dahl – JSConf EU 2018</a>.</p>\n<p><strong>TJ Holowaychuck</strong>, the guy behind the most popular Node.js framework: <strong>Express.js</strong>, among other things, says in 2014: <a href=\"https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b\">Farewell Node.js</a>, and mentions some pain points:</p>\n<blockquote>\n  <p>“I’ve been fighting with Node.js long enough in production now that I don’t enjoy working with it anymore unfortunately, so at least for now this my formal farewell!”</p>\n  <p>“I still plan on using Node for web sites.”</p>\n  <p>“Moral of the story, don’t get stuck in your own bubble! See what else is out there, you just might enjoy programming again. There are a lot of awesome solutions out there, my mistake was waiting too long to play around with them!☺.”</p>\n</blockquote>\n<p><strong>Scale Drone</strong> is one of many companies that have seen performance gains after switching to Go:</p>\n<blockquote>\n  <p>“Go servers use a third of the memory that our Node.js servers did. In addition to the memory usage lowering, both response and connections times were reduced significantly” – Scale Drone <a href=\"https://www.scaledrone.com/blog/nodejs-to-go/\">(2016 From Node.js to Go)</a></p>\n</blockquote>\n<p>Enough said about Node.js.</p>\n<h1 id=\"goatgoogle\">Go at Google</h1>\n<p><a href=\"https://www.quora.com/How-is-Go-used-at-Google-What-could-be-areas-specific-systems-applications-in-which-Go-could-replace-other-languages-used-nowadays-inside-Google-and-why-would-it-make-sense-to-introduce-Go-in-place-of-another-language\">Robert Love</a> who works at Google says:</p>\n<blockquote>\n  <p>“Go is designed specifically as a systems programming language for large, distributed systems and highly-scalable network servers. In that vein, it replaces C++ and Java in Google (company)'s software stack. Many teams are looking at building new servers in Go; some are even considering migrating existing codebases. Some of the Google technology you use every day has components written in Go.”</p>\n</blockquote>\n<p><a href=\"https://golang.org/doc/faq#creating_a_new_language\">The Go Team</a> says:</p>\n<blockquote>\n  <p>“Go was born out of frustration with existing languages and environments for the work we were doing at Google”. “… Programming had become too difficult and the choice of languages was partly to blame. One had to choose either efficient compilation, efficient execution, or ease of programming; all three were not available in the same mainstream language. Programmers who could were choosing ease over safety and efficiency by moving to dynamically typed languages such as Python and JavaScript rather than C++ or, to a lesser extent, Java”.</p>\n</blockquote>\n<p>Also, see <a href=\"http://matt-welsh.blogspot.com/2013/08/rewriting-large-production-system-in-go.html\">Rewriting a large production system in Go</a> – By <strong>Matt Welsh</strong>, 2013, in which the prior language used was C++.</p>\n<h1 id=\"conclusion\">Conclusion</h1>\n<p>There is a lot to be said about Go itself, maybe that would be a topic for another post. I think Go established itself on the server-side and the cloud, and as a modern general purpose programming language. You should definitely take a look at it.</p>\n<p>Read more:</p>\n<ul>\n<li><a href=\"https://github.com/golang/go/wiki/WhyGo\">Why Go?</a></li>\n<li><a href=\"https://talks.golang.org/2012/splash.article\">Go at Google: Language Design in the Service of Software Engineering</a></li>\n</ul>",
    "link": "/posts/server-side-languages.html",
    "date": "2020-05-00",
    "category": "posts",
    "desc": "Comparing Go, PHP, Java, Python, and Node.js",
    "lang": "en",
    "dir": "ltr"
  }
]